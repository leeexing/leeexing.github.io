{"meta":{"title":"LEE","subtitle":"keep simple | keep sunshine","description":"to be want to be","author":"Leeing","url":"http://leeeing.com"},"pages":[{"title":"About","date":"2017-12-29T10:55:20.000Z","updated":"2018-07-16T08:30:47.461Z","comments":false,"path":"about/index.html","permalink":"http://leeeing.com/about/index.html","excerpt":"","text":"姓名：LEE 职业：web前端开发工程师 地点：北京 - 宇宙中心 邮箱：lixingyaha@163.com 微信：LEE星"},{"title":"","date":"2018-07-16T08:30:47.461Z","updated":"2018-07-16T08:30:47.461Z","comments":true,"path":"about/resuse.me.html","permalink":"http://leeeing.com/about/resuse.me.html","excerpt":"","text":"about12我喜欢听音乐"},{"title":"categories","date":"2017-12-27T03:51:04.000Z","updated":"2018-07-16T08:30:47.462Z","comments":true,"path":"categories/index.html","permalink":"http://leeeing.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-27T03:53:31.000Z","updated":"2018-07-16T08:30:47.473Z","comments":true,"path":"tags/index.html","permalink":"http://leeeing.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"下半年的战场","slug":"源数据管理平台","date":"2018-07-16T08:35:57.000Z","updated":"2018-07-16T09:04:51.237Z","comments":true,"path":"2018/07/16/源数据管理平台/","link":"","permalink":"http://leeeing.com/2018/07/16/源数据管理平台/","excerpt":"一个项目 源数据管理平台 感想 有点紧张 自己需要尝试独立负责一个项目。之前一直是开发前端，现在可能需要考虑后台的一些逻辑了。","text":"一个项目 源数据管理平台 感想 有点紧张 自己需要尝试独立负责一个项目。之前一直是开发前端，现在可能需要考虑后台的一些逻辑了。 该如何下手 先将前端基本的页面搭建出来 先mock数据实现简单的页面效果 思考后台如何和现有的数据库进行对接 框架选择前端： vue – 相对来说比较熟悉 element-ui (25k,目前项目在使用，较为熟悉) / iView (14k,之前没有用过，想尝试一下) 后台： python – 比较熟悉，基本的实现还可以；技术上有申育可以探讨 node + koa2 – 个人博客在使用，比较熟悉 数据库： mongodb – 较为熟悉（集群之类的使用式盲点） mySQL – 使用还可以。python项目中使用过 整理架构前后端分离是必须的。所以需要建立两个项目之前的做个人博客的时候，将 server 放在的 blog 项目内。后面感觉到管理起来有点麻烦 功能 逐步完善 接下来可能会牵涉到保密内容，后面不会进行进一步的更新。只会写一些项目开发过程中的一些感悟，技术方面遇到的一些坑和总结业务方面的东西暂时不表 参考 iView","categories":[],"tags":[{"name":"work","slug":"work","permalink":"http://leeeing.com/tags/work/"}]},{"title":"2018-summer","slug":"2018-summer","date":"2018-07-06T09:13:25.000Z","updated":"2018-07-16T08:30:47.449Z","comments":true,"path":"2018/07/06/2018-summer/","link":"","permalink":"http://leeeing.com/2018/07/06/2018-summer/","excerpt":"不知不觉就夏天 七月 好多工作没有完成一些想法没有实现一些念头没有尝试受了点伤，养了会病静待这一月","text":"不知不觉就夏天 七月 好多工作没有完成一些想法没有实现一些念头没有尝试受了点伤，养了会病静待这一月 致敬 勒布朗 畅想 世界杯 学习一点一点学，虽然还是感觉有点慢，至少在进步 捣鼓了一下 vps ，顿时感觉需要学习的内容太多了。但，起码跨出了这一步 生活近一段时间，都是缺乏锻炼的。还在打球时不小心受伤了嗯操蛋的生活。。。还在继续 其他时间过了很久似的，太久没有更新这里的博客了一来有点忙二者自己水平实在也有限，写不出什么质量的文章，大多是一些瞎逼逼三思一下，还是做好自己的本职工作，继续充实地提升自己","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://leeeing.com/tags/总结/"}]},{"title":"march caprice","slug":"march-caprice","date":"2018-03-10T01:16:09.000Z","updated":"2018-07-16T08:30:47.452Z","comments":true,"path":"2018/03/10/march-caprice/","link":"","permalink":"http://leeeing.com/2018/03/10/march-caprice/","excerpt":"","text":"杂想技术栈最近公司在招人，看了一位 python 的简历，发现自己真的还有很多只是需要去学习起码对于一个框架，自己要比较熟练的使用才算合格。不能只是了解一点基本的，简单运用一下。重要的是需要多去实践 自己之前还是处于一种不太 open 的态度，对于技术有一点自私，眼界看起来太狭隘了，厉害的人是那种喜欢技术分享的，不会感觉到自己将知识分享出去会让自己变得落后，反而是人家会学习更多的知识不怕被人超越心态上还是需要再做调整","categories":[],"tags":[{"name":"随想","slug":"随想","permalink":"http://leeeing.com/tags/随想/"}]},{"title":"2018 spring","slug":"2018-spring","date":"2018-03-02T01:26:28.000Z","updated":"2018-07-16T08:30:47.448Z","comments":true,"path":"2018/03/02/2018-spring/","link":"","permalink":"http://leeeing.com/2018/03/02/2018-spring/","excerpt":"春天来了 一年之计在于春 重新上路新的一年开始了，需要给自己赋予更多的能量 工作之前就预料到2018年，自己会比较的忙碌。有个项目分配到自己身上，同时项目重构上面自己也还有很多的事情需要处理，两边都需要花费自己不小的精力。再有就是自己可能还需要帮助涛哥处理一些样式上面的问题，这一点还是尽快去帮涛哥解决吧，不然后面的事情一多，可能就无暇顾及了。尽量是不要加班到太晚，同时也是每周都有时间去操场锻炼跑步的时间，需要自己合理的去安排这一切 工作上面，可能大部分都是一些重复性比较多的工作了，我在想，如何在这个过程中也能增进自己的业务能力和工作效率。需要从哪个方面去考虑才可能说做的工作是更有效的。例如多考虑一些设计模式的使用，布局时多考虑以后的可扩展性，变量命名的时候是否做到了语义化，函数是否足够简洁并且可控，也就是多思考《重构》书中所讲的一些要点。我觉得这一点如果能够做得好，对以后的项目开发都是很有帮助的 多看书，多看一些与本专业相关的书籍，只有看得多了，思考的点才会更加的发散灵活多浏览技术网站，遇到好的文章，尽量自己去尝试一下，然后写下自己的总结体会，可以的话，给与文章作者一个友好的感谢性的回复","text":"春天来了 一年之计在于春 重新上路新的一年开始了，需要给自己赋予更多的能量 工作之前就预料到2018年，自己会比较的忙碌。有个项目分配到自己身上，同时项目重构上面自己也还有很多的事情需要处理，两边都需要花费自己不小的精力。再有就是自己可能还需要帮助涛哥处理一些样式上面的问题，这一点还是尽快去帮涛哥解决吧，不然后面的事情一多，可能就无暇顾及了。尽量是不要加班到太晚，同时也是每周都有时间去操场锻炼跑步的时间，需要自己合理的去安排这一切 工作上面，可能大部分都是一些重复性比较多的工作了，我在想，如何在这个过程中也能增进自己的业务能力和工作效率。需要从哪个方面去考虑才可能说做的工作是更有效的。例如多考虑一些设计模式的使用，布局时多考虑以后的可扩展性，变量命名的时候是否做到了语义化，函数是否足够简洁并且可控，也就是多思考《重构》书中所讲的一些要点。我觉得这一点如果能够做得好，对以后的项目开发都是很有帮助的 多看书，多看一些与本专业相关的书籍，只有看得多了，思考的点才会更加的发散灵活多浏览技术网站，遇到好的文章，尽量自己去尝试一下，然后写下自己的总结体会，可以的话，给与文章作者一个友好的感谢性的回复 生活 不止眼前的苟且 首先的一点是要有一个健康的身体。所以，每天的坚持锻炼时很重要的回去就不要再盯着手机了，先将基本的锻炼目标达成了再去处理其他的事情。在没有其他重要紧急事情的情况下，回家第一件最重要的事情就是锻炼每个周末能有一次户外锻炼的机会，如果是短程的话，早上希望能够来公司一趟，做点工作总结和计划。保持一个良好的生活作息，没有必要周末开始熬夜同时第二天懒觉睡到中午，这样其实还是很累的。正常的时间休息，第二天稍微起晚点就很好了。不要为了放纵而放纵。作息规律是很重要的 学习 终身学习是避免不了的 说好的，这一年要在后台方面有一个质的飞跃。所以不光是在学习视频或者书籍上要下功夫，最重要的还是要有足够的实践。给自己挤出一点时间来好好练习多和在这方面有经验的同事交流，尽可能利用好身边的资源 最重要的一点其实就是两个字 – 坚持 《重构》 使软件容易被理解和修改 代码的坏味道 重复代码 过长函数 过大的类 过长的参数列 发散式变化 散弹式修改 依恋情结 数据泥团 基本类型偏执 switch 惊悚 冗余类 令人迷惑的暂时字段 果断耦合的消息链 狎昵关系 异曲同工的类 不完美的类库 纯稚的数据类 过多的注释 重新组织函数提炼函数内嵌函数内嵌临时变量以查询取代临时变量引入解释性变量分解临时变量移除对参数的赋值以函数对象取代函数替换算法 在对象之间搬移特性 搬移函数 搬移字段 提炼类 将类内联化 隐藏“委托关系” 移除中间人 引入外加函数 引入本地扩展 重新组织数据 以对象取代数组 将单向关联改为双向关联 以字面常量取代魔法数 封装集合、字段 以数据类型取代记录 以类型取代类型码","categories":[],"tags":[{"name":"summary","slug":"summary","permalink":"http://leeeing.com/tags/summary/"}]},{"title":"js API learning","slug":"js-API-learning","date":"2018-02-06T09:14:51.000Z","updated":"2018-07-16T08:30:47.452Z","comments":true,"path":"2018/02/06/js-API-learning/","link":"","permalink":"http://leeeing.com/2018/02/06/js-API-learning/","excerpt":"JS API工作中是不是遇到一些新的问题，哎呦，这个API使用得很顺手 FileReader这个 api 之前几乎是不会用到的。最近项目中做图像显示相关的时候发现需要将之前的base64读取出来，之前是先获取图片的的路径存放地址，再通过 sqllite 获取到图片的详细的 base64 图像数据。而 fileReader 这个api恰好能够将一个图片的读取成 baseUrl的格式，用于具体业务的图像显示恰到好处不多说，直接上代码吧","text":"JS API工作中是不是遇到一些新的问题，哎呦，这个API使用得很顺手 FileReader这个 api 之前几乎是不会用到的。最近项目中做图像显示相关的时候发现需要将之前的base64读取出来，之前是先获取图片的的路径存放地址，再通过 sqllite 获取到图片的详细的 base64 图像数据。而 fileReader 这个api恰好能够将一个图片的读取成 baseUrl的格式，用于具体业务的图像显示恰到好处不多说，直接上代码吧 FileReader123456789101112131415161718192021222324252627282930313233343536373839// 基本使用let reader = new FileReader()let xhr = new XMLHttpRequest()xhr.open('get', url, true)xhr.responseType = 'blob'xhr.onload = function() &#123; if (this.status === 200) &#123; // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容。 reader.readAsDataURL(this.response) // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 reader.readerAsText() // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。 reader.readAsBinaryString() &#125;&#125;xhr.send()reader.onabort = function(evnet) &#123; // 该事件在读取操作被中断时触发。 console.log('阻止触发')&#125;reader.onerror = e =&gt; &#123; console.log('哎呦，文件读取发生错误')&#125;reader.onload = e =&gt; &#123; console.log('文件下载完成')&#125;reader.onloadend = e =&gt; &#123; console.log('最后的最后一定执行')&#125;reader.onloadstart = e =&gt; &#123; console.log('文件读取开始')&#125;reader.onprogress = e =&gt; &#123; // 该事件在读取Blob时触发。 console.log('可以实时控制显示进度')&#125; 具体使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556getImgDataUrl(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let reader = new FileReader() let xhr = new XMLHttpRequest() xhr.open('get', url, true) xhr.responseType = 'blob' xhr.onload = function() &#123; if (this.status === 200) &#123; reader.readAsDataURL(this.response) &#125; &#125; xhr.send() reader.onerror = e =&gt; &#123; reject(e) &#125; reader.onload = e =&gt; &#123; resolve(e.target.result) &#125; &#125;)&#125;getImgDataTxt(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let reader = new FileReader() let xhr = new XMLHttpRequest() xhr.open('get', url, true) xhr.responseType = 'blob' xhr.onload = function() &#123; if (this.status === 200) &#123; reader.readAsText(this.response) &#125; &#125; xhr.send() reader.onerror = e =&gt; &#123; reject(e) &#125; reader.onload = e =&gt; &#123; resolve(e.target.result) &#125; &#125;)&#125;init_show_img(baseUrl) &#123; this.base_url = baseUrl Promise.all([this.getImgDataUrl(`images/ct_img/$&#123;baseUrl&#125;/$&#123;baseUrl&#125;_1.0_CT.png`), this.getImgDataTxt(`images/ct_img/$&#123;baseUrl&#125;/$&#123;baseUrl&#125;_1.0_CT.png.txt`), this.getImgDataTxt(`images/ct_img/$&#123;baseUrl&#125;/suspect_cubes_information_$&#123;baseUrl&#125;_1.0_CT.png.txt`)]) .then(data =&gt; &#123; this.show_raw_img(data) // console.log(data) &#125;)&#125;这里才发现 Promise.all 真的很好用 FormData具体代码在 github 里面的 js/formData 中 重点要说明的是： 其实后端是这么处理的1、首先将文件上传到后端2、后端处理后直接保存在 对应的文件件中，文件名可以保持不变3、将上传的图像或者文件数据转成一个 md5 字段保存在数据库中，然后每次上传的时候首先访问数据库中是否上传过这个数据（md5是唯一的）。没有的话就进行上传并保存，上传过的就直接返回4、下次某个 api 需要请求数据的时候，只需要将对应资源的物理路径冲数据库中取出来并返回即可5、返回的数据资源（例如图像），需要给资源添加 协议 + 域名 + 端口 （eg: http://localhost:8001/images/123.png） indexedDBw3c不再维护web sql 所以很有必要了解一下 indexedDB 这个符合前端逻辑思维的 web 存储 api 文章的链接放在 github js/indexedDB","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://leeeing.com/tags/js/"},{"name":"api","slug":"api","permalink":"http://leeeing.com/tags/api/"}]},{"title":"2018.01 summary","slug":"2018-01-summary","date":"2018-02-02T00:52:03.000Z","updated":"2018-07-16T08:30:47.447Z","comments":true,"path":"2018/02/02/2018-01-summary/","link":"","permalink":"http://leeeing.com/2018/02/02/2018-01-summary/","excerpt":"2018年1月总结 小楼昨夜又东风 工作工作中一如既往的稳","text":"2018年1月总结 小楼昨夜又东风 工作工作中一如既往的稳 学习一、python 没有太多的时间花在这个知识点上面。没有能够做到熟练，基本的语法使用没有问题，涉及到不常用的库时还是需要停下来查一查，了解一些具体使用 跟着网上的一个学习教程，练习了二十来道简单的python入门题，重点是在于熟练基本的语法和类库的使用。对于以后解决某个问题时能够有一个快速联想到的方向，不至于毫无头绪 重复练习了一遍python简单的爬虫，用于的 react项目中展示。做简单的查询分类，同时也是为了熟练的使用 mongodb。但是数据量还是偏少了。下次爬网易云音乐的时候打算做一次数量比较大的爬取 对于python，基本还是处于一个写def的过程，写class还是比较少。这方面还需要多去练习 二、react 这个花的时间算是比较多的。关键还是在于对redux使用的不熟练，不知道数据如何通信传递、不同组件之间如何获取的全局的state。一开始停留在props进行传递，发现非父子组件之间就比较困难了，在使用 redux 之前使用了 pubsub 这种订阅发布的模式，简单解决了 一直对于一个系统的权限限制不是很熟，接着这个react-blog的项目，搭配python+flask作为后台管理，总算有点感觉了，但还不能做到得心应手的理解。现在使用的是flask的seesion机制来判断。而我了解到使用cookie进行判断也是可行的，而且目前工作中就是使用的这种机制，将相关的信息保存在cookie中，每一次发起一个请求的时候，通过 axios 的 before——request进行auth的判断，对应在headers中添加相应的cookie信息，而后后端进行判断这个cookie信息是否有效。目前没有测试使用cookie方式，下一步想试试。同时有一个疑问，如果访问的是一个静态页面，没有发起后台请求，那么这个路由会进行判断登录与否的判断吗？这里没有一个前端路由跳转就判断权限的钩子函数可供使用，我也没有一直想清楚。看看吧，后面继续学习是否会解答这个疑问 react-router还没有实现配置化，现在的处理还是一堆的route元素嵌入组件中，是不是这个版本的路由就是这么使用的 三、vue 没有做多少工作，主要还是指导老弟更加熟练的使用vue，其中也偶尔会发现自己的一些知识盲点 恭喜老弟进入熊厂 生活 一切静好 没有太多的波澜，今年北京的冬天还是太冷了，基本上打击了我外出的念头，当然，一部分也还是自己想要学习充电 锻炼偏少的原因，工作中自己似乎犯了职业病，右侧肩膀最近老是不舒服。猜想的原因主要是，缺乏锻炼、久坐不活动、办公姿势不正确 给家里置办了一些年货，爸妈这一年也辛苦了 期待回家过年 接下来 考虑一下好好学习 ubuntu 的 linux 这个系统。上周末就尝试安装 ubuntu 了。结果担心将机子搞坏。结果昨天同事恰好也安装 ubuntu。所以跟着他一起将 ubuntu 系统安装了。逼格有点高啊。 重点还是学习一些 shell 编程吧 将python与后台服务进行到底。重点去实验一下 mongodb 的集群和分片思想。理解 mongodb 能够带来的 noSQL 思想","categories":[{"name":"生活","slug":"生活","permalink":"http://leeeing.com/categories/生活/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://leeeing.com/tags/总结/"},{"name":"plan","slug":"plan","permalink":"http://leeeing.com/tags/plan/"}]},{"title":"show me the code | python","slug":"show-me-the-code","date":"2018-01-26T09:24:35.000Z","updated":"2018-07-16T08:30:47.455Z","comments":true,"path":"2018/01/26/show-me-the-code/","link":"","permalink":"http://leeeing.com/2018/01/26/show-me-the-code/","excerpt":"SHOW ME THE CODE 当你在学 python 的时候，你在想什么 针对具体的问题查漏补缺才是最快的学习后续会持续更新自己在学习过程中的python习题 具体查看我的 github python 项目","text":"SHOW ME THE CODE 当你在学 python 的时候，你在想什么 针对具体的问题查漏补缺才是最快的学习后续会持续更新自己在学习过程中的python习题 具体查看我的 github python 项目 第 0000 题：将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 类似于图中效果 头像 第 0001 题：做为 Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？ 第 0002 题:将 0001 题生成的 200 个激活码（或者优惠券）保存到 MySQL 关系型数据库中。 第 0003 题： 将 0001 题生成的 200 个激活码（或者优惠券）保存到 Redis 非关系型数据库中。 第 0004 题： 任一个英文的纯文本文件，统计其中的单词出现的个数。 第 0005 题： 你有一个目录，装了很多照片，把它们的尺寸变成都不大于 iPhone5 分辨率的大小。 第 0006 题： 你有一个目录，放了你一个月的日记，都是 txt，为了避免分词的问题，假设内容都是英文，请统计出你认为每篇日记最重要的词。 第 0007 题： 有个目录，里面是你自己写过的程序，统计一下你写过多少行代码。包括空行和注释，但是要分别列出来。 第 0008 题： 一个HTML文件，找出里面的正文。 第 0009 题： 一个HTML文件，找出里面的链接。 第 0010 题： 使用 Python 生成类似于下图中的字母验证码图片 字母验证码 阅读资料 第 0011 题： 敏感词文本文件 filtered_words.txt，里面的内容为以下内容，当用户输入敏感词语时，则打印出 Freedom，否则打印出 Human Rights。 北京 程序员 公务员 领导 牛比 牛逼 你娘 你妈 love sex jiangge 第 0012 题： 敏感词文本文件 filtered_words.txt，里面的内容 和 0011题一样，当用户输入敏感词语，则用 星号 * 替换，例如当用户输入「北京是个好城市」，则变成「**是个好城市」。 第 0013 题： 用 Python 写一个爬图片的程序，爬 这个链接里的日本妹子图片 :-) 参考代码 第 0014 题： 纯文本文件 student.txt为学生信息, 里面的内容（包括花括号）如下所示： { “1”:[“张三”,150,120,100], “2”:[“李四”,90,99,95], “3”:[“王五”,60,66,68]}请将上述内容写到 student.xls 文件中，如下图所示： student.xls 阅读资料 腾讯游戏开发 XML 和 Excel 内容相互转换 第 0015 题： 纯文本文件 city.txt为城市信息, 里面的内容（包括花括号）如下所示： { “1” : “上海”, “2” : “北京”, “3” : “成都”}请将上述内容写到 city.xls 文件中，如下图所示： city.xls 第 0016 题： 纯文本文件 numbers.txt, 里面的内容（包括方括号）如下所示： [ [1, 82, 65535], [20, 90, 13], [26, 809, 1024]]请将上述内容写到 numbers.xls 文件中，如下图所示： numbers.xls 第 0017 题： 将 第 0014 题中的 student.xls 文件中的内容写到 student.xml 文件中，如下所示： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;students&gt;&lt;!-- 学生信息表 \"id\" : [名字, 数学, 语文, 英文]--&gt;&#123; \"1\" : [\"张三\", 150, 120, 100], \"2\" : [\"李四\", 90, 99, 95], \"3\" : [\"王五\", 60, 66, 68]&#125;&lt;/students&gt;&lt;/root&gt; 第 0018 题： 将 ## 第 0015 题中的 city.xls 文件中的内容写到 city.xml 文件中，如下 所示： 12345678910111213&lt;?xmlversion=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;cities&gt;&lt;!-- 城市信息--&gt;&#123; \"1\" : \"上海\", \"2\" : \"北京\", \"3\" : \"成都\"&#125;&lt;/cities&gt;&lt;/root&gt; 第 0019 题： 将 ## 第 0016 题中的 numbers.xls 文件中的内容写到 numbers.xml 文件中，如下所示： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;&lt;numbers&gt;&lt;!-- 数字信息--&gt;[ [1, 82, 65535], [20, 90, 13], [26, 809, 1024]]&lt;/numbers&gt;&lt;/root&gt; 第 0020 题： 登陆中国联通网上营业厅 后选择「自助服务」 –&gt; 「详单查询」，然后选择你要查询的时间段，点击「查询」按钮，查询结果页面的最下方，点击「导出」，就会生成类似于 2014年10月01日～2014年10月31日通话详单.xls 文件。写代码，对每月通话时间做个统计。 第 0021 题： 通常，登陆某个网站或者 APP，需要使用用户名和密码。密码是如何加密后存储起来的呢？请使用 Python 对密码加密。 阅读资料 用户密码的存储与 Python 示例 阅读资料 Hashing Strings with Python 阅读资料 Python’s safest method to store and retrieve passwords from a database 第 0022 题： iPhone 6、iPhone 6 Plus 早已上市开卖。请查看你写得 ## 第 0005 题的代码是否可以复用。 第 0023 题： 使用 Python 的 Web 框架，做一个 Web 版本 留言簿 应用。 阅读资料：Python 有哪些 Web 框架 留言簿参考 第 0024 题： 使用 Python 的 Web 框架，做一个 Web 版本 TodoList 应用。 SpringSide 版TodoList 第 0025 题： 使用 Python 实现：对着电脑吼一声,自动打开浏览器中的默认网站。 例如，对着笔记本电脑吼一声“百度”，浏览器自动打开百度首页。 关键字：Speech to Text参考思路：1：获取电脑录音–&gt;WAV文件 python record wav 2：录音文件–&gt;文本 STT: Speech to Text STT API Google API3:文本–&gt;电脑命令 感谢Yixiaohan","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://leeeing.com/tags/python/"},{"name":"code","slug":"code","permalink":"http://leeeing.com/tags/code/"}]},{"title":"python common use modules","slug":"python-library","date":"2018-01-24T02:51:13.000Z","updated":"2018-07-16T08:30:47.453Z","comments":true,"path":"2018/01/24/python-library/","link":"","permalink":"http://leeeing.com/2018/01/24/python-library/","excerpt":"","text":"python 常用 &amp; 备忘 enumerateenumerate()是python的内置函数enumerate在字典上是枚举、列举的意思对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值enumerate多用于在for循环中得到计数 1234567list1 = [\"这\", \"是\", \"一个\", \"测试\"]for i in range (len(list1)): print i ,list1[i]list1 = [\"这\", \"是\", \"一个\", \"测试\"]for index, item in enumerate(list1): print index, item enumerate还可以接收第二个参数，用于指定索引起始值 12345678910list1 = [\"这\", \"是\", \"一个\", \"测试\"]for index, item in enumerate(list1, 1): print index, item如果要统计文件的行数，可以这样写count = len(open(filepath, 'r').readlines()) -- 这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。count = 0for index, line in enumerate(open(filepath,'r'))： count += 1","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"http://leeeing.com/tags/后端/"},{"name":"python","slug":"python","permalink":"http://leeeing.com/tags/python/"}]},{"title":"命名规范","slug":"name-norm","date":"2018-01-22T01:16:31.000Z","updated":"2018-07-16T08:30:47.453Z","comments":true,"path":"2018/01/22/name-norm/","link":"","permalink":"http://leeeing.com/2018/01/22/name-norm/","excerpt":"","text":"name normCamel Case小驼峰命名法：第一个单词的首字母小写；第二个单词开始每个单词的的首字母大写。例如：firstName、lastName。 大驼峰命名法（Upper Camel Case：每一个单词的首字母都大写。例如：FirstName、LastName、CamelCase。也被称为 Pascal 命名法（Pascal Case）,源自于 Pascal 语言的命名惯例。 Snake Case这是书写复合词或短语的一种惯例（practice）。复合词或短语中的各个单词之间用下划线（_）分隔并且没有空格。复合词中的每一个单词的首字母通常都是小写的，并且复合词的第一个字母既可以是大写的又可以是小写的，例如：“foo_bar”和“Hello_world”。一般认为 Snake Case 的可读性要比 Camel Case 要强。","categories":[],"tags":[{"name":"规范","slug":"规范","permalink":"http://leeeing.com/tags/规范/"},{"name":"python","slug":"python","permalink":"http://leeeing.com/tags/python/"}]},{"title":"React Learn","slug":"react-learn","date":"2018-01-19T03:11:33.000Z","updated":"2018-07-16T08:30:47.454Z","comments":true,"path":"2018/01/19/react-learn/","link":"","permalink":"http://leeeing.com/2018/01/19/react-learn/","excerpt":"react一些基本概念","text":"react一些基本概念 生命周期 constructor(props, context)：构造函数，在创建组件的时候调用一次。 componentWillMount()：在组件挂载之前调用一次。如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次。 componentDidMount()：在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs。 componentWillReceiveProps(nextProps)：props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。 shouldComponentUpdate(nextProps, nextState)：组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。 componentWillUpdate(nextProps, nextState)：shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。 componentDidUpdate()：除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。 componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用。 更新方式 首次渲染Initial Render 调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render） 父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render） 调用this.forceUpdate 组件在初始化时会触发5个钩子函数： getDefaultProps() 设置默认的props，也可以用dufaultProps设置组件的默认属性。 getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。 componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 componentDidMount() 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。 react-python react负责前端，python负责后端 解决跨域1、在 package.json 中配置 proxy配合python的 flask 框架 package.json1234567891011121314151617181920212223&#123; \"name\": \"blog\", \"version\": \"0.1.0\", \"private\": true, \"dependencies\": &#123; \"antd\": \"^3.1.3\", \"axios\": \"^0.17.1\", \"node-sass\": \"^4.7.2\", \"react\": \"^16.2.0\", \"react-dom\": \"^16.2.0\", \"react-router-dom\": \"^4.2.2\", \"react-scripts\": \"1.1.0\", \"sass\": \"^1.0.0-beta.4\", \"sass-loader\": \"^6.0.6\" &#125;, \"scripts\": &#123; \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" &#125;, \"proxy\": \"http://localhost:5000/\" // python flask 默认的端口（可配置）&#125; 2、项目中安装 axios 。如上的 dependencies 3、app.py python-server12345678910111213141516171819from flask import Flask, jsonify, make_responseimport pymongoapp = Flask(__name__)client = pymongo.MongoClient('localhost', 27017)user_db = client['myblog']['users']@app.route('/api/users', methods=['GET'])def users(): data = &#123; 'success': True, 'msg': 'leeing' &#125; return jsonify(data)if __name__ == \"__main__\": # app.run(host='192.168.191.1') app.run(debug=True) 3、使用 react-demo123456789101112131415161718192021222324252627class Music extends React.Component &#123; componentWillMount() &#123; axios.get('/api/users').then(res =&gt; &#123; console.log(res) &#125;) &#125; render() &#123; return ( &lt;div className=\"m-music\"&gt; &lt;h1&gt;我的音乐，我的电台&lt;/h1&gt; &lt;Button&gt;检查一些字段&lt;/Button&gt; &lt;/div&gt; ) &#125;&#125;// 控制台就可以获取到了&#123;data: &#123;…&#125;, status: 200, statusText: \"OK\", headers: &#123;…&#125;, config: &#123;…&#125;, …&#125; config:&#123;adapter: ƒ, transformRequest: &#123;…&#125;, transformResponse: &#123;…&#125;, timeout: 0, xsrfCookieName: \"XSRF-TOKEN\", …&#125; data: msg:\"leeing\" success:true __proto__:Object headers:&#123;date: \"Sun, 21 Jan 2018 02:25:17 GMT\", server: \"Werkzeug/0.14.1 Python/3.6.4\", connection: \"keep-alive\", x-powered-by: \"Express\", content-length: \"42\", …&#125; request:XMLHttpRequest &#123;onreadystatechange: ƒ, readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, …&#125; status:200 statusText:\"OK\" 但是我就是想要使用 fetch 不想使用 axios 怎么办？ 1、后端配置可跨域 app.py1234567891011121314151617181920212223from flask import Flask, jsonify, make_responseimport pymongoapp = Flask(__name__)client = pymongo.MongoClient('localhost', 27017)user_db = client['myblog']['users']@app.route('/api/users', methods=['GET'])def users(): data = &#123; 'success': True, 'msg': 'leeing' &#125; rst = make_response(jsonify(data)) rst.headers['Access-Control-Allow-Origin'] = '*' rst.headers['Access-Control-Allow-Methods'] = 'GET' rst.headers['Access-Control-Allow-Headers'] = 'x-requested-with,content-type' return rst, 200if __name__ == \"__main__\": # app.run(host='192.168.191.1') app.run(debug=True) 主要是配置 返回信息的 headers 头部信息 2、fetch 使用 music.jsx12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Music extends React.Component &#123; componentWillMount() &#123; // 第一版比较复杂，还以为这里还需要将后台的端口配置上，同时 fetch 的时候还继续将 headers 配置好。其实没有这个必要了 // 只要后端配置好了额就可以了 // fetch('http://localhost:5000/api/users', &#123; // method: 'GET', // mode: 'cors', // headers: &#123; // 'Content-Type': 'application/x-www-form-urlencoded' // &#125; // &#125;) // .then(res =&gt; &#123; // console.log(res) // console.log(res.headers.get(\"content-type\")) // return res.json() // 这里就可以使用 res.json（） 了 // &#125;) // .then(data =&gt; &#123; // console.log(data) // &#125;) fetch('/api/users') .then(res =&gt; &#123; console.log(res) console.log(res.headers.get(\"content-type\")) return res.json() &#125;) .then(data =&gt; &#123; console.log(data) &#125;) &#125; render() &#123; return ( &lt;div className=\"m-music\"&gt; &lt;h1&gt;我的音乐，我的电台&lt;/h1&gt; &lt;Button&gt;检查一些字段&lt;/Button&gt; &lt;/div&gt; ) &#125;&#125;// 控制台返回的信息Response &#123;type: \"basic\", url: \"http://localhost:3000/api/users\", redirected: false, status: 200, ok: true, …&#125;music.jsx:13 application/jsonmusic.jsx:17 &#123;msg: \"leeing\", success: true&#125; 总结：暂时还不知道为什么使用 axios ，后端就可以不用再配置 返回信息的头部了而且如果是使用 fetch 这样的方式，每一个请求都需要这是一个响应的头部，那不就复杂了。应该是有一个统一的设置到底使用 axios 还是 fetch。可以自己衡量 403 一堆的 403 下载图片报错 403-image125fd296f2f4cb16e.jpg:1 GET https://img3.doubanio.com/view/site/median/public/5fd296f2f4cb16e.jpg 403 ()Image (async)","categories":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/tags/前端/"},{"name":"react","slug":"react","permalink":"http://leeeing.com/tags/react/"}]},{"title":"TESTful learning","slug":"TESTful-learning","date":"2018-01-19T01:58:12.000Z","updated":"2018-07-16T08:30:47.451Z","comments":true,"path":"2018/01/19/TESTful-learning/","link":"","permalink":"http://leeeing.com/2018/01/19/TESTful-learning/","excerpt":"RESTful正好周末开始为 react-blog 写后台。先充电学习一些如何设计 api 几乎都是参考 阮一峰老师的教程。有空了，再在自己实践的基础上，加上自己的一点理解和感悟。 一、理解 理论 REST，即Representational State Transfer的缩写 – 表现层状态转化 如果一个架构符合REST原则，就称它为RESTful架构。 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义","text":"RESTful正好周末开始为 react-blog 写后台。先充电学习一些如何设计 api 几乎都是参考 阮一峰老师的教程。有空了，再在自己实践的基础上，加上自己的一点理解和感悟。 一、理解 理论 REST，即Representational State Transfer的缩写 – 表现层状态转化 如果一个架构符合REST原则，就称它为RESTful架构。 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义 资源REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，*如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 二、使用 实战 路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees HTTP动词对于资源的具体操作类型，由HTTP动词表示。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 下面是一些例子。 example12345678GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 error123&#123; error: \"Invalid API key\"&#125; 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 response123456&#123;\"link\": &#123; \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\"&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表 123456789101112&#123; \"current_user_url\": \"https://api.github.com/user\", \"authorizations_url\": \"https://api.github.com/authorizations\", // ...&#125;从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。&#123; \"message\": \"Requires authentication\", \"documentation_url\": \"https://developer.github.com/v3\"&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://leeeing.com/categories/后端/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://leeeing.com/tags/后端/"},{"name":"restful","slug":"restful","permalink":"http://leeeing.com/tags/restful/"}]},{"title":"vue-sundry 杂项","slug":"vue-sundry","date":"2018-01-17T01:27:07.000Z","updated":"2018-07-16T08:30:47.458Z","comments":true,"path":"2018/01/17/vue-sundry/","link":"","permalink":"http://leeeing.com/2018/01/17/vue-sundry/","excerpt":"vue 杂谈时不时会发现自己还有一些知识点是遗漏的","text":"vue 杂谈时不时会发现自己还有一些知识点是遗漏的 会按照时间顺序来，后面添加的放在前面 statics &amp; assets You will notice in the project structure we have two directories for static assets: src/assets and static/. What is the difference between them? Webpacked Assets在 *.vue 组件中，所有模板和CSS都会被 vue-html-loader 及 css-loader 解析，并查找资源URL。例如，在 和 background: url(./logo.png) 中，”./logo.png” 是相对的资源路径，将由Webpack解析为模块依赖。 因为 logo.png 不是 JavaScript，当被视为模块依赖时，需要使用 url-loader 和 file-loader处理它。vue-cli 的 webpack 脚手架已经配置了这些 loader，因此可以使用相对/模块路径。 由于这些资源可能在构建过程中被内联/复制/重命名，所以它们基本上是源代码的一部分。这就是为什么建议将Webpack 处理的静态资源放在 /src 目录中和其它源文件放一起的原因。事实上，甚至不必把它们全部放在 /src/assets：可以用模块/组件的组织方式来使用它们。例如，可以在每个放置组件的目录中存放静态资源。 “Real” Static Assets相比之下，static/ 目录下的文件并不会被 Webpack 处理：它们会直接被复制到最终目录（默认是dist/static）下。必须使用绝对路径引用这些文件，这是通过在 config.js 文件中的 build.assetsPublicPath 和 build.assetsSubDirectory 连接来确定的。 任何放在 static/ 中文件需要以绝对路径的形式引用：/static/[filename]。如果更改 assetSubDirectory 的值为 assets，那么路径需改为 /assets/[filename]。 assets里面的会被webpack打包进你的代码里，而static里面的，就直接引用了。一般在static里面放一些类库的文件，在assets里面放属于该项目的资源文件。 简单的讲，static放别人家的，assets放自己写的。 props之前使用 props 的时候都是通过父组件传递一个属性到子组件，子组件内部通过一个 props: [&#39;prop-name&#39;] 的属性接收来自父组件传递过来的数据而最近重新研读 vue 的官方文档。发现遗漏了 props 在子组件中的验证官方：我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告，这对于开发给他人使用的组件非常有用。双手赞成 – 以后我自己也要封装一些我觉得常用的组件。或者我项目中私人定制的组件。 自己尝试1234567891011121314151617181920export default &#123; name: 'slot', props: &#123; name: &#123; type: String, required: true &#125;, items: &#123; validator (val) &#123; return Object.prototype.toString.call(val) === '[object Array]' &#125; &#125; &#125;, data () &#123; return &#123; hi: 'I dont know what this present', topic: '抡起巴比伦' &#125; &#125;&#125; 亲自测试过后，原本items 是一个需要父组件使用本组件时，传入一个数组类型的属性。如果时对象或者函数，那都是会提示错误信息的。注意到，验证 items 的时候，我使用了 validator 函数，自定义验证规则。这点很爽！ nextTick 等时间","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/tags/前端/"},{"name":"vue","slug":"vue","permalink":"http://leeeing.com/tags/vue/"}]},{"title":"slot:使用插槽分发内容 学习","slug":"vue-slot","date":"2018-01-16T05:46:30.000Z","updated":"2018-07-16T08:30:47.457Z","comments":true,"path":"2018/01/16/vue-slot/","link":"","permalink":"http://leeeing.com/2018/01/16/vue-slot/","excerpt":"vue-slot父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。 在编写组件的内容里面存在 &lt;slot&gt; 插口","text":"vue-slot父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。 在编写组件的内容里面存在 &lt;slot&gt; 插口 单个插槽顾名思义，组件里面只有一个插口 &lt;slot&gt;&lt;/slot&gt; 注意：如果子组件里面模板里面没有 插口，那么从父组件里面给子组件添加的内容加会被抛弃 my-component123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; parent-component1234567&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; render-output12345678&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 要是 my-component 组件里面没有 slot,那么子组件只会渲染 h2 标签里面的内容 youdontwant123456&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt; 具名插槽插槽多了，需要给 slot 增加一个特殊的属性 name 具名插槽将匹配内容片段中对应的 slot 特性的元素 – name 相同的放入对应的slot里面，没有匹配到的 slot name，放入默认的 匿名插槽里面 1234567891011121314151617181920212223242526272829303132333435&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;// 在具体的某个页面中调用子组件，里面同时插入内容&lt;app-layout&gt; &lt;h1 slot=\"header\"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=\"footer\"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt;// 渲染出来的结果&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 作用于插槽（加鸡腿）将子组件的值传到父组件供使用 用作一个（能被传值的）可重用模板，来代替已经渲染好的元素 传递数据的方向有点不同：这里是子组件向父组件传递而我们最常见的是父组件通过 props 向子组件传递数据 slot-scop123&lt;div class=\"child\"&gt; &lt;slot text=\"hello from child\" msg=\"tomorrow is wednesday\"&gt;&lt;/slot&gt;&lt;/div&gt; parent-component1234567891011// 具体调用子组件是，需要用到 &lt;template&gt;&lt;/template&gt; 元素 -- 作用于插槽的模板// slot-prop 的值表示 接收 从子组件传递多来的 prop 对象。 这里是 &#123;text：\"hello from child\"&#125;&lt;div class=\"parent\"&gt; &lt;child&gt; &lt;template slot-scope=\"props\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;p&gt;&#123;&#123; props.msg &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; rendering-output1234567&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;p&gt;tomorrow is wednesday&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 在 2.5.0+，slot-scope 能被用在任意元素或组件中而不再局限于 &lt;template&gt; 这里还没有消化好 自定义渲染1234567891011&lt;my-slot :items=\"items\"&gt; &lt;li slot=\"item\" slot-scope=\"props\" class=\"slot-item\" &gt; &#123;&#123; props.text&#125;&#125; -- &#123;&#123; props.msg &#125;&#125; &lt;/li&gt; // 第二版 &lt;h1&gt;&lt;/h1&gt;&lt;/my-slot&gt; 子组件1234567891011121314151617181920212223&lt;!-- 列表组件的模板 --&gt;&lt;template&gt; &lt;div class=\"slot\"&gt; &lt;ul&gt; &lt;slot name=\"item\" v-for=\"item in items\" :text=\"item.text\" :msg=\"item.msg\" &gt; what 123 &lt;!-- &lt;p&gt;什么意思&lt;/p&gt; --&gt; &lt;/slot&gt; &lt;slot&gt;我在这里又增加了一点内容&lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'slot', props: ['items']&#125;&lt;/script&gt; output123456789&lt;ul data-v-10cb672e=\"\"&gt; &lt;li data-v-80180a8e=\"\" data-v-10cb672e=\"\" class=\"slot-item\"&gt; what you -- haha &lt;/li&gt;&lt;li data-v-80180a8e=\"\" data-v-10cb672e=\"\" class=\"slot-item\"&gt; hello -- world &lt;/li&gt; // 第二版 我在这里又增加了一点内容 // 这里并没有渲染出 h1 标签&lt;/ul&gt; 还不是很理解这里的使用套路 摘自知乎的一个回答：vue的作用域插槽本质上就是一个具名slot，将父组件作用域的&lt;template&gt;与子组件的具名slot绑定，从而让子组件能直接在slot中写v-for、v-if等渲染DOM结构;并借&lt;template&gt;的scope特性接收子slot传递的数据，在template中填充其内容。 更具上面的提示，修改一下之前的代码 update123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=\"slot\"&gt; &lt;ul&gt; &lt;slot name=\"item\" v-for=\"item in items\" :text=\"item.text\" :msg=\"item.msg\" &gt; what 123 &lt;!-- &lt;p&gt;什么意思&lt;/p&gt; --&gt; &lt;!-- 这里写入备用内容 --&gt; &lt;/slot&gt; &lt;slot name=\"test\" info=\"I dont know what this present\"&gt; 我也不知道这里些什么 &lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'slot', props: ['items'], data () &#123; return &#123; hi: 'I dont know what this present', topic: '抡起巴比伦' &#125; &#125;&#125;&lt;/script&gt;// parent&lt;my-slot :items=\"items\"&gt; &lt;li slot=\"item\" slot-scope=\"props\" class=\"slot-item\" &gt; &#123;&#123; props.text&#125;&#125; -- &#123;&#123; props.msg &#125;&#125; &lt;/li&gt; &lt;h1 slot=\"test\" slot-scope=\"props\"&gt;&#123;&#123; props.info &#125;&#125;&lt;/h1&gt;&lt;/my-slot&gt;// output&lt;ul data-v-10cb672e=\"\"&gt; &lt;li data-v-80180a8e=\"\" data-v-10cb672e=\"\" class=\"slot-item\"&gt; what you -- haha &lt;/li&gt;&lt;li data-v-80180a8e=\"\" data-v-10cb672e=\"\" class=\"slot-item\"&gt; hello -- world &lt;/li&gt; &lt;h1 data-v-80180a8e=\"\" data-v-10cb672e=\"\"&gt;I dont know what this present&lt;/h1&gt; // 这个时候渲染出了 h1 标签&lt;/ul&gt; 能再来一个实际一点的例子就好了 实际例子12 别人优秀的使用 组件中存在slot插槽，使其能够将父组件作用域的内容渲染子组件中 template中scope对象包含的值主要是在子组件上通过作用域插槽slot的属性决定的 再读杂项在编写组件时，最好考虑好以后是否要进行复用。一次性的组件间有紧密的耦合没有关系。但是可服用组件应该定义一个清晰的公开接口，同时也不要对其使用的外层数据做出任何假设 Vue 组件的API来自三个部分 – prop、事件、插槽 Prop 允许外部环境传递数据给组件 事件 允许组件内触发外部环境的副作用 插槽 允许外部环境将额外的内容组合在组件内 这里的第三条，给了我一点对 slot 的理解 123456789&lt;my-component :foo=\"baz\" :bar=\"qux\" @event-a=\"doThis\" @event-b=\"doThat\"&gt; &lt;img slot=\"icon\" src=\"...\"&gt; &lt;p slot=\"main-text\"&gt;Hello!&lt;/p&gt;&lt;/my-component&gt; 组件命名当注册组件或者 prop 时，可以使用 kebab-case（短横线分割命名）、camelCase（驼峰式命名）、PascalCase（单词首字母大写命名） 123456789// 在组件定义中components: &#123; // 使用 kebab-case 注册 'kebab-cased-component': &#123; /* ... */ &#125;, // 使用 camelCase 注册 'camelCasedComponent': &#123; /* ... */ &#125;, // 使用 PascalCase 注册 'PascalCasedComponent': &#123; /* ... */ &#125;&#125; 但是在 HTML 模板中，请使用 kebab-case： 123&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt; 如果组件未经 slot 元素传入内容，你甚至可以在组件名后使用 / 使其自闭合： &lt;my-component/&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://leeeing.com/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://leeeing.com/tags/vue/"}]},{"title":"学习 React-router4 时踩的坑","slug":"react-rouuter@4","date":"2018-01-16T02:39:44.000Z","updated":"2018-07-16T08:30:47.455Z","comments":true,"path":"2018/01/16/react-rouuter@4/","link":"","permalink":"http://leeeing.com/2018/01/16/react-rouuter@4/","excerpt":"React-router.V4路由规则位于布局和 UI 本身之间 前面 BB不得不吐槽，用过 Vue-router，过来再使用这个，很不爽","text":"React-router.V4路由规则位于布局和 UI 本身之间 前面 BB不得不吐槽，用过 Vue-router，过来再使用这个，很不爽 理论学习直接上手，到处是埋伏 思维模式的转变 概念上将，路由就是一个基本的单元，基本上是一个梅花的配置文件 1&lt;Route path=\"/home\" component=&#123;Home&#125;&gt; 关键字 exact 1&lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; exact 的意思是，需要完全匹配。也有排他性的意思 – 只有一条路由获胜 包容性路由 只要匹配上路由，就进行内渲染 123456789101112const PrimaryLayout = () =&gt; ( &lt;div className=\"primary-layout\"&gt; &lt;header&gt; Our React Router 4 App &lt;Route path=\"/users\" component=&#123;UsersMenu&#125; /&gt; &lt;/header&gt; &lt;main&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users\" component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;) 当我们访问 /users 时，两个组件都会渲染，相同或者不同都没有关系 排他性路由 来匹配其中的一个路由 12345678910111213const PrimaryLayout = () =&gt; ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users/add\" component=&#123;UserAddPage&#125; /&gt; &lt;Route path=\"/users\" component=&#123;UsersPage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt;) 在 /users 之前策略性地放置了 /users/add 的路由，以确保正确匹配。由于路径 /users/add 将匹配 /users 和 /users/add，所以最好先把 /users/add 放在前面。如果遇到，&lt;Redirect&gt; 组件将会始终执行浏览器重定向，但是当它位于 语句中时，只有在其他路由不匹配的情况下，才会渲染重定向组件。 嵌套布局 这里挖坑挖得最深 表面上看，嵌套布局很简单，但根据你的选择，可能会因为你 组织路由的方式 而遇到阻碍。 反面教材123456789101112131415161718192021222324252627282930313233343536373839const PrimaryLayout = props =&gt; &#123; return ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/users/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;Route path=\"/products\" exact component=&#123;BrowseProductsPage&#125; /&gt; &lt;Route path=\"/products/:productId\" component=&#123;ProductProfilePage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; )&#125;const BrowseUsersPage = () =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;BrowseUserTable /&gt; &lt;/div&gt; &lt;/div&gt;)const UserProfilePage = props =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;UserProfile userId=&#123;props.match.params.userId&#125; /&gt; &lt;/div&gt; &lt;/div&gt;) 可以看到，下面的两个组件中存在相同的 UserNav 组件，这回产生一个重复渲染的问题，因为每次 UserProfilePage 或 BrowseUsersPage 被渲染的时候，一个新的 UserNav 实例被创建， 思路就应该是将相同的业务组件放在一起 正面例子1234567891011121314151617181920212223242526272829const PrimaryLayout = props =&gt; &#123; return ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/users\" component=&#123;UserSubLayout&#125; /&gt; &lt;Route path=\"/products\" component=&#123;ProductSubLayout&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; )&#125;const UserSubLayout = () =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=\"/users\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/users/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;) 区别在于，将 user 的子路由和基本路由放在同一个组建里面。如此，共同的组件 UserNav` 组件就不会被重复渲染了注意：我们在布局结构中深入嵌套，路由仍然需要识别它们的完整路径才能匹配。为了节省重复输入（以防你决定将“用户”改为其他内容），请改用 props.match.path 优化12345678910111213const UserSubLayout = props =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=&#123;props.match.path&#125; exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;props.match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;) 匹配 Props.match 对于知道详情页面渲染的 UserId 以及如何编写沃恩的路由是很有用的。match 对象给我嗯提供了几个属性呢 match.params match.path // 路由编写的路径：/users/:userId | 优先选择一个 match.url // 浏览器 URL 中的实际路径：/users/12 避免匹配冲突 一个场景：我们希望能够通过访问 /users/add 和 /users/5/edit 来新增和编辑用户 多重匹配123456789101112131415const UserSubLayout = (&#123; match &#125;) =&gt; ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route exact path=&#123;props.match.path&#125; component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/add`&#125; component=&#123;AddUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId/edit`&#125; component=&#123;EditUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;) Attention： 为了确保进行适当的匹配，新增和编辑路由需要战略性地放在详情路由之前。如果详情路径在前面，那么访问 /users/add 时将匹配详情（因为 “add” 将匹配 :userId）。 如果我们这样创建路径 ${match.path}/:userId(\\d+)，来确保 :userId 必须是一个数字，那么我们可以先放置详情路由 授权路由 根据用户的登陆状态来限制用户访问某些路由 对于未经授权的页面（如“登录”和“忘记密码”）与已授权的页面（应用程序的主要部分）看起来不一样也是常见的。 解决这个问题，需要考虑一个应用程序的主要入口点 这不就是我一开始遇到的问题吗？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class App extends React.Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/auth\" component=&#123;UnauthorizedLayout&#125; /&gt; &lt;AuthorizedRoute path=\"/app\" component=&#123;PrimaryLayout&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ) &#125;&#125;// 我遇到的问题是这样的class AppRoute extends React.Component &#123; constructor() &#123; super() this.state = &#123; &#125; &#125; render() &#123; return ( &lt;Router&gt; &lt;div className=\"app\"&gt; // 第三版：直到使用了 Switch 这个路由控制器。包裹在里面的路由只会匹配到一个 路由。 &lt;Switch&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &lt;Route path=\"/\" component=&#123;Home&#125; /&gt; &lt;/Switch&gt; // 第二版：我想增加一个login页面，但是他的基本布局适合home（‘/’）页面是不一样的 -- 没有 菜单栏，侧边栏之类的，只有空白的登陆表单 // 这样写的问题是，我访问 login 路由的时候，还是会将 index 页面的一些布局渲染出来，这可不是我想要的结果 &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; // 第一版：最初还没有增加 login页面，没有什么大问题，路由放在一起就好了 &#123;/* &lt;Router&gt; &lt;main className=\"content\"&gt; &lt;Header /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/article\" component=&#123;Article&#125;/&gt; &lt;Route path=\"/todolist\" component=&#123;Todo&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;/main&gt; &lt;/Router&gt; */&#125; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;class Home extends React.Component &#123; render() &#123; return ( &lt;div className=\"home\"&gt; &lt;Header /&gt; &lt;Route path=\"/todolist\" component=&#123;Todo&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/article\" component=&#123;Article&#125; /&gt; &lt;Route path=\"*\" render=&#123;() =&gt; ( &lt;h3&gt;沉舟侧畔千帆过&lt;/h3&gt; )&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 使用 react-redux 与 React Router v4 非常类似，就像之前一样，只需将 BrowserRouter包在 中即可。 但是 AuthorizedRoute 不是 React-routerV4 的一部分，不能通过 react-router-dom 导出。需要自己根据相关 V4文档 辅助编写完成 授权123456789101112131415161718192021222324class AuthorizedRoute extends React.Component &#123; componentWillMount() &#123; getLoggedUser() &#125; render() &#123; const &#123; component: Component, pending, logged, ...rest &#125; = this.props return ( &lt;Route &#123;...rest&#125; render=&#123;props =&gt; &#123; if (pending) return &lt;div&gt;Loading...&lt;/div&gt; return logged ? &lt;Component &#123;...this.props&#125; /&gt; : &lt;Redirect to=\"/auth/login\" /&gt; &#125;&#125; /&gt; ) &#125;&#125;const stateToProps = (&#123; loggedUserState &#125;) =&gt; (&#123; pending: loggedUserState.pending, logged: loggedUserState.logged&#125;)export default connect(stateToProps)(AuthorizedRoute) 首先，使用网络请求来 getLoggedUser()，并将 pending 和 logged 插入 Redux 的状态中。pending 仅表示在路由中请求仍在继续。 其他提示 Link NavLink NavLink 匹配浏览器的 URL。它可以让我们给任何一个激活的链接设置一个 active 样式。如果没有 exact，由于 v4 的包容性匹配策略，那么在访问 /app/users 时，主页的链接将处于激活中所以参看文章的作者建议：NavLink 带 exact属性等价于 v3 的 ，而且更稳定 动态路由 最好的部分之一 React-router4 中，几乎所有的东西（包括 &lt;Route&gt; ）都是 React 的一个组件，都是要拿来进行渲染的。 总结路由不再是那么难以理解了 我们可以在我们的组件中随时随地的渲染 &lt;Route&gt;。当满足某些条件（path匹配）时，应用程序的整个内容都可以路由到 相干组件，进行渲染，当某些条件不满足的时候，我们可以一处路由，隐藏某些组件，或者渲染其他的一些组件什么？还有 递归路由。好吧，我还需要继续学习 看来，默写组件只需要向上面那样，只写一个简单的 函数就可以了，不必要写一个 class 类。而且，写函数的话，传参更加方便 从一个简单的 todolist 开始学 react，到开始尝试使用 react-router，满满都是坑啊。但是，看完了一些前人的总结之后，猛地还是有很多豁然开朗的感觉继续学习 感谢 填坑的道路上，你们的分享就是指路明灯 关于 React Router 4 的一切","categories":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/tags/前端/"},{"name":"react","slug":"react","permalink":"http://leeeing.com/tags/react/"}]},{"title":"Vue 数据绑定学习","slug":"vue-dataBinding","date":"2018-01-12T02:01:50.000Z","updated":"2018-07-16T08:30:47.456Z","comments":true,"path":"2018/01/12/vue-dataBinding/","link":"","permalink":"http://leeeing.com/2018/01/12/vue-dataBinding/","excerpt":"双向数据绑定将DOM与Vue实例的data数据绑定在一起，彼此之间相互影响","text":"双向数据绑定将DOM与Vue实例的data数据绑定在一起，彼此之间相互影响 简单的数据绑定知识Object.defineProperty 用法： Object.defineProperty(obj, ‘key’, descriptor) 123456789101112131415161718192021let obj = &#123;&#125;let fooObject.defineProperty(obj, 'lee', &#123; value: 'ing', // 几个描述符的值 默认都为 false wirtabel: false, // 可更改 configurable: false, // 属性是否可删除，以及其他特性是否可被修改 enumerable: false // 可枚举 for ... in 和 Object.keys() // or // get，set 不能和value一起出现 get() &#123; // 返回值,必须要指定返回值 // return foo return obj.msg &#125;, set(val) &#123; // obj.lee = val &#125;&#125;) 原理Object.defineProperty 中的 get 和 set 方法 – 访问器：会随着数据的变化而直接变化 当我们将一个普通的 js 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter用户看不到 getter/setter， 但是内部他们让 Vue 追踪依赖，在属性被访问和修改的时候通知变化。每个组件实例都有相应的 watcher 实例对象，他会在组件渲染的过程中把属性记录为依赖，之后依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新 一个简单的数据双向绑定的例子1234567891011121314151617181920212223&lt;input type=\"text\" id=\"txt\" /&gt;&lt;span id=\"sp\"&gt;&lt;/span&gt;&lt;script&gt;var txt = document.getElementById('txt'), sp = document.getElementById('sp'), obj = &#123;&#125;// 给对象obj添加msg属性，并设置setter访问器Object.defineProperty(obj, 'msg', &#123; // 设置 obj.msg 当obj.msg反生改变时set方法将会被调用 set: function (newVal) &#123; // 当obj.msg被赋值时 同时设置给 input/span txt.value = newVal sp.innerText = newVal &#125;&#125;)// 监听文本框的改变 当文本框输入内容时 改变obj.msgtxt.addEventListener('keyup', function (event) &#123; obj.msg = event.target.value&#125;)&lt;/script&gt; 注意事项当数据之前没有在 data 里面。但是后面的逻辑需要往 data 里面动态添加新的数据、属性的时候，这个心添加的数据是 非响应式的因为 Vue 在初始化实例的时候对属性执行 getter/setter 转化过程，所以属性必须在 data 对象存在才能让 Vue 转化它。这样才能实现响应。所以对于后面动态添加进来的数据， Vue 检测不到但是，可以使用下面两种方式实现对这些数据的再次监测 Vue.set(object, key, value) - 适用于添加单个属性 Object.assign() - 适用于添加多个属性 1、如果是实例上面的数据，可以这样 1this.$set(this.someObject, 'foo', someValue) 2、适用于向已有对象添加一些属性，可以使用 Object.assign()。但是，添加到对象上的新属性不会触发更新。这种情况可以创建一个新的对象，让它饱含对象的属性和新的属性 1this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123;foo:'cat', age: 23&#125;) 和这个联系比较紧密的异步DoM更新Vue 异步执行 DOM 更新，只要观测到数据变化，Vue 将会开启一个队列，并缓冲在同一个事件循环中发生的所有数据变化。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲是去除重复数据对于避免不必要的计算和DOM操作上非常重要。然后在下一个时间循环 tick 中， Vue 刷新队列并执行时机工作当我们直接设置 vm.someData = ‘new value’ 该组件不会立即重新渲染。组件只会在下一个事件循环队列清空时的下一个 tick 更新。如果我们想要立即获取到更新后的数据，则需要通过 Vue.nextTick(callback) – 在DOM 更新后，执行某个操作。实力的话调用 vm.￥nextTick（function()） 123456789methods: &#123; someMethod () &#123; this.msg = 'cahnge' // 假设原来的 this.msg == 'origin' this.$nextTick(() =&gt; &#123; console.log(this.$el.children[0].innerText) &#125;) console.log(this.msg) // 还会是原来的值 origin &#125;&#125; Vue 中的计算属性123456789101112131415161718192021222324252627data () &#123; return &#123; rawData: [1,2,3,4,5,6] &#125;&#125;,computed: &#123; // 计算属性的 getter -- 敲黑板 showData () &#123; return this.rawData.slice(0,3) &#125;&#125;既然计算属性有个 getter，当然也就有个 settercomputed: &#123; // 注意：这里不是一个函数方法，而是一个 对象。就有点想 Object.defineProperty 中的 descriptor fullName: &#123; // getter get () &#123; return this.firstname + ' ' + this.lastnAME &#125;, // setter set (newVal) &#123; // do somethig &#125; &#125;&#125; Vue 双向数据绑定 – 源码学习核心思想是 Object.defineProperty 和 发布-订阅 模式 整体结构 改造 Vue 实例中的 data， 通过 Object.defineProperty 将其所有属性设hi为访问器属性 对每个属性添加 Observer，并在 observer 中添加订阅者对象序列 添加订阅者对象 Watcher，每次初始化的时候添加到对应 data 属性中的 Dep 中 简而言之：监听数据变化，管理订阅者/管理者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Dep 用于订阅者的存储和收集import Dep from 'Dep`export default class Observer &#123; constructor (value) &#123; this.value = value this.walk(value) &#125; walk(value) &#123; Object.keys(value).forEach(key =&gt; this.convert(key, value[key])) &#125; convert(key, val) &#123; defineReactive(this.value, key, val) &#125;&#125;export function defineReactive(obj, key, val) &#123; // 用于存放某个属性的所有订阅者 let dep = new Dep() let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get () &#123; // 如果Dep类存在target属性，将其添加到dep实例的subs数组中 // target指向一个Watcher实例，每个Watcher都是一个订阅者 // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法 if (Dep.target) &#123; dep.addSub(Dep.target) &#125; return val &#125;, set (newVal) &#123; if (val === newVal) &#123; return &#125; val = newVal childOb = observe(newVal) dep.notify() &#125; &#125;)&#125;export function observe(value) &#123; if (!value || typeof value !== 'object') &#123; return &#125; return new Observer(value)&#125; 管理订阅者 1234567891011export default class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; this.subs.push(sub) &#125; notify() &#123; this.subs.forEach(sub =&gt; sub.update()) &#125;&#125; 订阅者 12345678910111213141516171819202122232425262728import Dep from 'Dep'export default class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.vm = vm // 被订阅的数据一定来自于当前Vue实例 this.cb = cb // 当数据更新时想要做的事情 this.expOrFn = expOrFn // 被订阅的数据 this.val = this.get() // 维护更新之前的数据 &#125; // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用 update() &#123; this.run() &#125; run() &#123; const val = this.get() if (val !== this.val) &#123; this.val = val this.cb.call(this.vm) &#125; &#125; get() &#123; // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this const val = this.vm._data[this.expOrFn] // 置空，用于下一个Watcher使用 Dep.target = null return val &#125;&#125; 实例 12345678910111213141516171819202122232425262728import Observer, &#123;observe&#125; from 'Observer'import Watcher from 'Watcher'export default class Vue &#123; constructor(options = &#123;&#125;) &#123; // 简化了$options的处理 this.$options = options // 简化了对data的处理 let data = this._data = this.$options.data // 将所有data最外层属性代理到Vue实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)) // 监听数据 observe(data) &#125; $watch(expOrFn, cb) &#123; new Watcher(this, expOrFn, cb) &#125; _proxy(key) &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get: () =&gt; this._data[key], set: (val) =&gt; &#123; this._data[key] = val &#125; &#125;) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/categories/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://leeeing.com/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://leeeing.com/tags/前端/"},{"name":"vue","slug":"vue","permalink":"http://leeeing.com/tags/vue/"}]},{"title":"vue directive 学习","slug":"vue-directive","date":"2018-01-11T09:55:47.000Z","updated":"2018-07-16T08:30:47.457Z","comments":true,"path":"2018/01/11/vue-directive/","link":"","permalink":"http://leeeing.com/2018/01/11/vue-directive/","excerpt":"使用 Vue Directive 封装 `DOM 操作` 指令 (Directives) 是带有 v- 前缀的特殊属性 作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM","text":"使用 Vue Directive 封装 `DOM 操作` 指令 (Directives) 是带有 v- 前缀的特殊属性 作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM vue directive 简介先放一张图 知道vue有 v-on、v-show、v-if 这些方便我们操作的指令吧对了，就像 vue 的 filter 一样，我们可以自己全局注册或者局部定义组件的名字和相关的指令操作 之前不怎么了解（使用），是没有遇到那个需求，今天做公司一个重构的时候，突然发现这个指令，很好 全局注册 123456Vue.directive('指令的名字', &#123; //一些option，提供许多hook function 定义directive的具体操作，如inserted、bind... inserted: function (el) &#123; //指令插入元素后的操作 &#125; &#125;) 局部注册 12345678910export default &#123; data () &#123; return &#123;&#125; &#125;, directives: &#123; name: &#123; //指令的名字 // 指令的定义 &#125; &#125;&#125; 钩子函数在定义的时候，VUe提供了许多 hook function。例如 inserted、bind等bind：只调用一次，在绑定的对象节点被插入父节点时调用一次的函数，可以用于初始化定义一些样式或者其他动作unbind：只调用一次，在元素被解除绑定时调用inserted：被绑定元素插入父节点时调用;父节点存在即可调用，不必存在于document中update：被绑定的元素所在的模板更新的时候调用，而不论绑定的值是否发生了变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新componentUpdated：被绑定元素所在的模板完成一次更新周期是调用 钩子函数参数指令钩子函数会被传入以下参数：el：指令所绑定的元素，可以用来直接操作 DOM 。binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1” arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 为什么要使用这个 vue directive 为了实现 view 和 viewModule 这两个层的分离 View 层负责页面上的显示，ViewModule 层负责改变|操作数据，由于Vue是基于数据驱动的，所以我们就不应该（尽量避免）在代码中操作 View 层上面的 DOM 元素另一方面，VUeDirective 是和 DOM 元素紧密联系在一起的，随着 DOM 的创建、销毁一起变化，也就相应的出发了上面说的几个 钩子函数。如此，vue direcitve的生命周期方法能够让我们以一种更加优雅的方式在合适的时机对 DOM 进行必要的操作。而viewModule里面没有和DOM元素相对应的方法，vue directive又是属于 VIew 层面的东西，所以 DOM 操作应该被封装在 vue directive 中 而不是 Vue 的实例中 demos官方vue123456789101112131415&lt;p v-color-swatch:lee.a=\"#f90\"&gt;&lt;/p&gt;Vue.directive('color-swatch', function (el, binding) &#123; console.log(binding) // Object&#123;name:'color-swatch', arg:'foo', rawName: 'v-color-swatch', value: '#f90', expression: '#f90', modifiers: &#123;&#125;, def: &#123;&#125;&#125; el.style.backgroundColor = binding.value&#125;)还可以传入对象面量&lt;div v-demo=\"&#123; color: 'white', text: 'hello!' &#125;\"&gt;&lt;/div&gt;Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"&#125;) 掘金学习： scroll 滚动后取数据vue12345678910111213141516171819202122232425262728293031323334351、首先将DOM操作封装到指令的option中let scrollCallback = function(callback) &#123; if (document.body.scrollHeight &lt; 1000) &#123; return &#125; if (document.body.scrollHeight - window.scrollY - 100 document.body.clientHeight) &#123; callback() &#125;&#125;let callBackWarpped // 新变量 保存引用export default &#123; bind: function(el, binding, vnode) &#123; callBackWarpped = scrollCallback.bind(&#123;&#125;, binding.value) window.addEventListener(\"scroll\", callBackWarpped) &#125;, unbind: function() &#123; window.removeEventListener(\"scroll\", callBackWarpped) &#125;&#125;2、import scrollDirective from '../../directives/scroll'3、在组件的directives属性中注册这个指令，值为scrolldirectives: &#123; scroll: scrollDirective //指令的名字:指令的option的名字&#125;,4、在相应元素上加上directive指令v-scroll = \"onScroll\"//v-'指令的名字' = \"回调函数\"5、编写directive指令中的函数在method中编写onScroll函数，也就是上文中对应的binding.value，在这个函数中我们将会请求更多数据，而Vue就会执行相应v-scroll中的值。 自己编写12345678910111213141516171819&lt;input v-leeing:foo.a=\"shello\" placeholder=\"自定义指令\"&gt;export default &#123; data () &#123; return &#123;&#125; &#125;, directives: &#123; chamelon: &#123; inserted (el, binding) &#123; el.style.background = binding.value &#125; &#125; leeing: &#123; inserted (el, binding) &#123; el.focus() // 插入的时候就自动聚焦 &#125; &#125; &#125;&#125; 参考：2018 我所了解的 Vue 知识大全 自定义事件v-on使用 v-on 绑定自定义事件 绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。 用在普通元素上时，只能监听 原生 DOM 事件。 用在自定义元素组件上时，也可以监听子组件触发的自定义事件。 每个 Vue 实力都实现了事件接口 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 $on 和 $emit 并不是 addEventListener 和 dispatchEvent 父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。注意：v-on 没有简写。：是 v-bind 的简写 ；v-on 是 @ 在监听原生 DOM 事件时，方法以事件为唯一的参数 12345&lt;!-- 对象语法 (2.4.0+) --&gt;&lt;button v-on=\"&#123; mousedown: doThis, mouseup: doThat &#125;\"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=\"doThis\"&gt;&lt;/button&gt; 在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)： 1234567&lt;my-component @my-event=\"handleThis\"&gt;&lt;/my-component&gt;&lt;!-- 内联语句 --&gt;&lt;my-component @my-event=\"handleThis(123, $event)\"&gt;&lt;/my-component&gt;&lt;!-- 组件中的原生事件 --&gt;&lt;my-component @click.native=\"onClick\"&gt;&lt;/my-component&gt; 如果需要在组件上监听一个原生事件。可以添加修饰符！ v-on:click.native=”doSomething” .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 12&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13=\"onEnter\"&gt; v-bind动态地绑定一个或多个特性，或一个组件 prop 到表达式。 在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象 在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。 没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。 几个语法糖v-modle 12345678&lt;input v-model=\"something\"&gt;等价于&lt;input v-bind:value=\"something\" v-on:input=\"something = $enent.target.value\"&gt; vue 书写规范 哪里都有规范","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://leeeing.com/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://leeeing.com/tags/前端/"},{"name":"vue","slug":"vue","permalink":"http://leeeing.com/tags/vue/"}]},{"title":"当你开始考虑前端规范的时候","slug":"when you think FE standard","date":"2018-01-10T10:39:44.000Z","updated":"2018-07-16T08:30:47.459Z","comments":true,"path":"2018/01/10/when you think FE standard/","link":"","permalink":"http://leeeing.com/2018/01/10/when you think FE standard/","excerpt":"我只是前端深井的挑水夫","text":"我只是前端深井的挑水夫 js 不造轮子，直接使用Airbnb前端规范 html 尽量语义化 保持良好的简洁结构123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;Title很重要，不要缺少&lt;/title&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;meta name=\"description\" content=\"\"/&gt; &lt;meta name=\"viewport\" content=\"width=device-width\"/&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"/&gt; &lt;link rel=\"shortcut icon\" href=\"img/favicon.ico\"/&gt; &lt;link rel=\"apple-touch-icon\" href=\"img/touchicon.png\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 注意: 12345678910111、 结构上如果可以并列书写，就不要嵌套。如果可以写成&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;那么就不要写成&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;2、如果结构已经可以满足视觉和语义的要求，那么就不要有额外的冗余的结构。比如&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/div&gt;已经能满足要求，那么就不要再写成&lt;div&gt;&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;3、一个标签上引用的className不要过多，越少越好。比如不要出现这种情况：&lt;div class=\"class1 class2 class3 class4\"&gt;&lt;/div&gt;4、对于一个语义化的内部标签，应尽量避免使用className。比如在这样一个列表中，li标签中的itm应去除：&lt;ul class=\"m-help\"&gt;&lt;li class=\"itm\"&gt;&lt;/li&gt;&lt;li class=\"itm\"&gt;&lt;/li&gt;&lt;/ul&gt; 在body 中，不同的业务模块之间，或者不同的逻辑大区块之间，可以备注简单的模块内容，一座提示只用 常用语义化标签1.、头部——header和nav标签 12345678910&lt;header&gt; &lt;h1&gt;html5语义化标签&lt;/h1&gt; &lt;nav&gt; &lt;h1&gt;导航&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;章节标签&lt;/li&gt; &lt;li&gt;标题标签&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; 2、 主体部分——main和section 12345678910111213141516&lt;main&gt; &lt;section&gt; &lt;hgroup&gt; &lt;h2&gt;章节标签&lt;/h2&gt; &lt;p&gt;为页面区分不同的章节&lt;/p&gt; &lt;/hgroup&gt; &lt;div&gt;包括section article nav aside &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;hgroup&gt; &lt;h2&gt;标题标签&lt;/h2&gt; &lt;p&gt;为不同的章节定义标题&lt;/p&gt; &lt;/hgroup&gt; &lt;div&gt;h1 h2 h3 h4 h5 h6六个标题标签&lt;/div&gt; &lt;/section&gt;&lt;/main&gt; 3、尾部——footer 123&lt;footer&gt; &lt;p&gt;copyright &amp;copy hello, world&lt;/p&gt;&lt;/footer&gt; 4、页面的轮廓 section、article、aside、nav 12345678aside &lt;aside&gt;&lt;/aside&gt;：指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。如果放在main内，应该与所在内容密切相关。article适用于独立性强的内容，如本身就是一篇文章、博客，或者用户的评论等，article比section更加强调需要包含一个标题标签h1~h6具体到项目中，适合于评论区部分，课件介绍 5、其它一些常用标签 123456789101112131415161718192021222324252627282930&lt;figure&gt;&lt;/figure&gt;：创建图（默认有40px左右margin）。&lt;small&gt;&lt;/small&gt;：指定细则，输入免责声明、注解、署名、版权。 只适用于短语，不要用来标记“使用条款”、“隐私政策”等长的法律声明。&lt;strong&gt;&lt;/strong&gt;：表示内容重要性。&lt;em&gt;&lt;/em&gt;：标记内容着重点（大量用于提升段落文本语义）。&lt;mark&gt;&lt;/mark&gt;：突出显示文本（yellow），提醒读者。&lt;cite&gt;&lt;/cite&gt;：指明引用或者参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。 只用于参考源本身，而不是从中引述。&lt;blockquoto&gt;&lt;/blockquoto&gt;：引述文本，默认新的一行显示。&lt;time&gt;&lt;/time&gt;：标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。 不再相关的时间用s标签。&lt;address&gt;&lt;/address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。 如果提供整个页面的作者联系信息，一般放在页面级footer里。不能包含文档或者文档等其他内容。&lt;del&gt;&lt;/del&gt;：移除的内容。&lt;ins&gt;&lt;/ins&gt;：添加的内容。&lt;code&gt;&lt;/code&gt;：标记代码。包含示例代码或者文件名 （&lt; &amp;lt; &gt; &amp;gt;）&lt;pre&gt;&lt;/pre&gt;：预格式化文本。保留文本固有的换行和空格。&lt;progress&gt;&lt;/progress&gt;：完成进度。可通过js动态更新value。 注意: 1&lt;center&gt;，&lt;font&gt; 不建议使用 Image 图片规范 命名顺序图片业务（可选） +（mod_）图片功能类别（必选）+ 图片模块名称（可选） + 图片精度（可选） 图片业务 px: 培训 yd: 云端 yw: 运维 … 图片功能 mon_: 是否公共 icon: 图标 logo: LOGO类 btn: 按钮 bg: 大背景或者可平铺 … 图片模块 useravatar: 用户头像 stdlist: 学员列表 picmap: 图像库 … 图片精度|描述 普通: @1x Retina: @2x | @3x 有颜色：@c、同类型有多中颜色用颜色区分 有背景：@bg 有边框：@bd … 示例1、使用比较多的icon图标痛点：造成好几个图标很类似，想换想统一，但是设计师就是在这个页面、这个模块里面这么设计，使用这个图标；怎么办？使用图片的功能或者模块进行划分 123456789101112131、图片库和试图学习都是使用相同的图标现状：tupianku、shituxuexi | 培训任务和培训管理的menu图标一样 | menu理论练习、记录方式：功能 + 模块优化：icon_mod_imgmap | icon_mod_book | icon_mod_record2、左右箭头，使用场景很多，只是大小的区分，切都是做按钮使用.现状：arrow-left, angle-left方式：功能 +优化：btn_arrow-left@1x、btn_arrow-left@2x3、添加按钮 +现状：有简单一个`+`号，有带背景圆圈的`+`号优化：btn_add、btn_add@bg 如果项目中期发现了之前的图标可以共用，不要怕麻烦，将图标名称改为 mod_ 共用的。然后在页面中找到对应的图标修改过来 图片格式GIF、PNG8、PNG24、JPEG、WEBP 约定： 内容图 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式 尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大 背景图 【背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片】 PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式 补充WebP，是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式 VP8特点：文件体积小，无损压缩后，比 PNG 文件少了 45％ 的文件大小；有损压缩后，比 JPEG 文件少了 25% - 34% 文件大小；浏览器兼容差 图片使用图标优先考虑icotfont, 再考虑图片精灵 123456&lt;img src=\"\" alt=\"\" &gt;CSS 中图片引入不需要引号.nuc &#123; background-image: url(icon.png);&#125; css 使用sass或者less，前期确定后统一使用一种编译语法 分类方法 css相关的文件夹 | 优先级比较高 css reset Mixin mod mod1 mod2 unit btn list input 代码风格1、代码风格： 展开 花括号前空一个 内容缩进四格 末尾添加分号 左括号与类名之间一个空格 冒号与属性值之间空一格 单个css选择器或新申明开启新行 不要为 0 指明单位 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0 CSS3 浏览器私有前缀在前，标准前缀在后 除非你需要透明度而使用rgba，否则都使用#f0f0f0这样的表示方法，并尽量缩写。 2、选择器： 不使用ID选择器 层级关系最多不要超过4级 3、书写顺序 布局定位属性：display / position / float / clear / visibility / overflow 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 1234567891011121314151617.nuc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; 4、注释格式 对选择器的注释统一写在被注释对象的上一行，对属性及值的注释写于分号后 注释内容两端需空格，已确保即使在编码错误的情况下也可以正确解析样式。 在必要的情况下，可以使用块状注释，块状注释保持统一的缩进对齐。 原则上每个系列的样式都需要有一个注释，言简意赅的表明名称、用途、注意事项等。 123456789/* 块状注释文字 * 块状注释文字 * 块状注释文字 */.m-list&#123;width:500px;&#125;.m-list li&#123;height:20px;line-height:20px;/* 这里是对line-height的一个注释 */overflow:hidden;&#125;.m-list li a&#123;color:#333;&#125;/* 单行注释文字 */.m-list li em&#123;color:#666;&#125; 使用 scss 文件夹加以区分 |– styles|——base – _base.scss // 定义基本的 class 类的样式。例如：body、footer、.wrapper、.page – _reset.scss // 充值基本的样式 – _variables.scss // 定义一些共用变量.例如：$prirmary: #F6E27F|——components // 公用组件样式 – _topbar.scss – _topnav.scss – _page.scss|——pages // 具体业务类组件样式。每个业务类顶层都用各自的业务类名称命名一个class类进行变量类名包裹 – _home.scss // 主页 – _post.scss // 提交 – _topic.scss // 课件 – _study.scss // 学习 – _image.dr/ct.scss // 图像|——mixin // 共用的mixin方法 – _btn.scss – _input.scss|——main.scss // 主文件，将上面的几个文件夹里面的.scss文件统一引入进来 分离出去的sass文件在命名的时候前面加下划线 _ ，这是告诉 sass不要编译这些文件，但是在 main.scss 导入的时候不需要添加下划线注意：不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。 命名规范 使用 - 连接符，不使用驼峰命名、全部小写 类别 名称 布局（grid） .g- 模块（module） .m- 元件（unit） .u- 功能（function） .f- 统一语义理解和命名 布局 语义 命名 简写 文档 doc doc 头部 head hd 主体 body bd 尾部 foot ft 主栏 main mn 主栏子容器 mainc mnc 侧栏 side sd 侧栏子容器 sidec sdc 盒容器 wrap/box wrap/box 模块、元件 语义 命名 简写 导航 nav nav 子导航 subnav snav 面包屑 crumb crm 菜单 menu menu 选项卡 tab tab 标题区 head/title hd/tt 内容区 body/content bd/ct 列表 list lst 表格 table tb 表单 form fm 热点 hot hot 排行 top top 登录 login log 标志 logo logo 广告 advertise ad 搜索 search sch 幻灯 slide sld 提示 tips tips 帮助 help help 新闻 news news 下载 download dld 注册 regist reg 投票 vote vote 版权 copyright cprt 结果 result rst 标题 title tt 按钮 button btn 输入 input ipt 最后 执行才能出效果","categories":[{"name":"前端","slug":"前端","permalink":"http://leeeing.com/categories/前端/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://leeeing.com/tags/规范/"},{"name":"前端","slug":"前端","permalink":"http://leeeing.com/tags/前端/"}]},{"title":"2018","slug":"2018","date":"2018-01-06T08:15:11.000Z","updated":"2018-07-16T08:30:47.450Z","comments":true,"path":"2018/01/06/2018/","link":"","permalink":"http://leeeing.com/2018/01/06/2018/","excerpt":"","text":"2018，「一切都会好起来」5.0🎭来北京两年半了【虽然】时间过得很快【但是】给自己加油的力量 路走了一遍又一遍回过头仍是少年 BB 操蛋的生活还在继续 不知道说点什么 Learning网站搭建 成熟的模板 + 域名 + 空间 wordpress | 腾讯课堂有视频介绍 github pages | 已在使用 python crawler flask | django matplotpy | PIL numpy | scipy | panda 数据库 mongodb mysql redis 读书清单前端 修改代码的艺术 重构 设计模式 后端 流畅的python python cookbook flak web开发 其他 []","categories":[],"tags":[{"name":"plan","slug":"plan","permalink":"http://leeeing.com/tags/plan/"}]},{"title":"2017年终总结","slug":"2017 year-end summary","date":"2017-12-31T04:56:45.000Z","updated":"2018-07-16T08:30:47.447Z","comments":true,"path":"2017/12/31/2017 year-end summary/","link":"","permalink":"http://leeeing.com/2017/12/31/2017 year-end summary/","excerpt":"说到底，人们烦恼的本质是来自自己无能","text":"说到底，人们烦恼的本质是来自自己无能 NewYear123export default 2017from 2018 import *, courage 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ BB未来不迎，当时不杂，过往不恋 工作工作总结和回顾差强人意 1、可圈可点：这一年基本上完成了分配到自己身上的任务。先说任务，不管是图库管理、CT/DR图像显示、学员的学、练、考核、统计模块，考题制作、展示、编辑的模块，都尽可能在最快的时间内完成了，中途还有过对之前业务模块的重构，使得可维护性比之前好很多；也对项目中可复用的页面进行了模块化，模仿vue一样通过数据进行导向，插件也进行了必要的封装，这一方面算是差强人意的表现。再说基本，对图像进一步优化升级上面我做的不够好，尤其CT/DR图像插入tip，手机端上面显示DR图像这几点上面，太依赖于算法那边的配合，没有算法的支持，自己这边前端交互的升级一直看不到明显的进展，也尝试过学习一些底层的知识，发现涉及的知识面比较多，没能深入下去。2、这一年工作能力表现上是能够得到团队的认可的，但是自己（领导）也发现我还不够积极主动的，开会发言比较少，技术交流偏少。除此之外，自己在把握全局产品思想上不够优秀，只是完成了一个业务需求，对业务本身解决的痛点缺少足够深入的思考；同时，对自己提出的经过自己编写的代码要尽可能少的被测试找出问题这一点，虽然自己统计上看出有所改善，但也暴露出一些问题，一是自己的不够细心，二是自己对这个需求的业务逻辑没有足够理解–至少没有测试理解透彻–导致交互逻辑上出现错误。这些虽然对完成工作最后影响不是很大，但是从效率和质量上面考虑还是 – 有待提高。 2018年工作计划持续跟进、独当一面 继续跟进图像显示操作相关功能的优化升级、和算法同事配合提升项目中CT/DR图像的交互效果，PC端培训项目中能够上线DR走图的功能，解决DR图像在手机端显示的问题新的一年，团队开始实行后端分离，可能自己会负责一些主要的前端模块或者新业务，可能是云门户、云图库资源管理等。这样的话前端的压力也会开始增加，很多的逻辑可能需要自己和同事去考虑，业务需求和交互效果也需要我们前端去沟通了解跟进，自己是否能有一个良好的全局把控力，在需求和展现上做到平衡。 对个人能力提升、培训、团队建设的建议吸收、视野 打铁还需自身硬，技术能力是自己的立身资本。所以保持一个终身学习的心态，一方面继续吸收前端的前沿技术；另一方面，接触后台，了解后台，使用后台思维去全局看待前端、看清业务的逻辑本质。可能会有一些收获。虽然自己不喜欢讲座式的技术交流，但是我希望自己能够保持一个技术开放的心态，以项目需求为出发点，结合业务和团队成员保持更多的技术交流。新的一年里，我希望能够扩大自己的视野。不局限于技术，还有自己的心态，自己的思维，看问题的角度能够更丰富一些。 学习学点后台 前端水还是很深 这一年重点学习(巩固)了一下这几个技术点 ES6 vue node + koa webpack 利用vue+koa实现了自己的一个前台显示后端管理的简单博客，里面添加了一些自己练习的功能，例如地图，websocket实时聊天，One， music展示列表等对webpack打工具有一定的了解与使用 后端路还很长 后台主要学习的python这门语言。很喜欢！ python flask 爬虫 MongoDB MySQL redis 对数据有跟进一步的认识，但还不足没有完成python搭建一个blog的最初项目，有点遗憾，新年里继续python爬虫还是比较简单的入门，没有掌握scrapy其实重点应该是学习http协议，打通前端到后端的壁垒 生活丰富多彩 游玩不就是玩嘛，没有什么可说的。太low了，只有国庆的时候去了一趟四川重庆游其他大部分时间都是在北京或者北京郊区游玩所以北京值得去的景点大部分都留下了足迹 读书这点做的不好，前半年还有地铁上看书的习惯，后半年几乎就不看了后期改为听书了，一开始觉得还不错，但是现在想起来缺少自己思考的读书，其实就是人家给你嚼烂的东西让你消化没有什么营养，留给自己思想提升的东西不多读书，这件事，不能偷懒 锻炼锻炼这件事似乎和天气关联起来了气温合适的时候，锻炼的频率比较多，也比较多样跑步，打球，爬山，骑车天气一冷下来，各种懒，一度一两个月都没怎么锻炼，瑜伽垫一直搁在角落定力和执行力还是不好其实回家如果没有直接玩手机或者打开电脑看NBA之类的还是有很充裕的时间锻炼的，意识层面的问题所以，18年会将这个态度更正过来好好锻炼all in 扩展交际少了一点参加了两次前端会议，却没有结识一位前端朋友或添加一位前端大牛，这不能不说是自己没有打开自己不要闭塞自己，尝试去沟通了解keep open 接下来和时间做朋友，过好每一天 保持简单，认真对待每一天多反思自己近期的一些工作学习表现，多总结将上一年不足之处好好的改正开通自己的博客之后，用心去维护做到，尽可能记录自己的学习过程记录自己的一些思考、感悟将自己近期的心得好好记录，因为是开放的，所以要keep real","categories":[{"name":"工作","slug":"工作","permalink":"http://leeeing.com/categories/工作/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://leeeing.com/tags/总结/"}]},{"title":"2017年最后一天上班","slug":"work-summary","date":"2017-12-29T11:25:35.000Z","updated":"2018-07-16T08:30:47.460Z","comments":true,"path":"2017/12/29/work-summary/","link":"","permalink":"http://leeeing.com/2017/12/29/work-summary/","excerpt":"借着这个机会，总结自己这一年工作中存在的问题以及反思如何减轻这些问题给工作上带来的不效率，为2018蓄力准备","text":"借着这个机会，总结自己这一年工作中存在的问题以及反思如何减轻这些问题给工作上带来的不效率，为2018蓄力准备 个人存在的问题 专业知识深度和广度不够 工作态度不够专业 工作效率不高效 文档整理能力不强 解决方案 专业知识深度和广度不够 自主学习，多浏览专业领域相关技术网站，技术文章 了解其他编程语言、前端开发不局限于前端，可以多了解后端的编程思维 培养逻辑推理和独立思考能力、深刻理解算法和数据结构等相关知识 向同事请教，多听取比较同事对某个问题的意见看法 工作态度不够专业 认真对待任何事情，不报应付的态度，脚踏实地，多花心思的去做事情 做事的时候，从多个角度考虑问题，有创意，对待问题从深层次分析，思考深刻，不把工作当作一种负担，时刻改进工作方法，提高工作效率 工作中遇到挫折可能会打击一些工作热情，做到坚持锻炼保持良好心态，积极心理暗示让自己保持客服困难的信心 工作效率不高效 做好每周工作计划总览、每日工作计划 做好每日工作总结、反思 多学习、提高专业知识能力处理复杂问题才能做到应对更从容、更效率 加强时间意识和紧迫感 文档整理能力不强 养成良好的程序注释习惯，而且要用准确的语句描述注释的内容，从写注释的一句话开始锻炼文字表达能力 阅读别人的相关优秀文档并模仿，锻炼文档编写的组织能力和文字表达能力。我们项目后端的相关接口文档就写得比较规范友好 尝试自己编写一些前端规范文档或者技术文档，总结亦或沉淀 总结时代在发展，技术在进步，要始终保持一颗拼搏向上的心。面对工作生活的各种困难，多反思多总结，不断学习进步。","categories":[],"tags":[{"name":"work","slug":"work","permalink":"http://leeeing.com/tags/work/"}]},{"title":"Christmas","slug":"Christmas","date":"2017-12-28T11:38:35.000Z","updated":"2018-07-16T08:30:47.450Z","comments":true,"path":"2017/12/28/Christmas/","link":"","permalink":"http://leeeing.com/2017/12/28/Christmas/","excerpt":"我住的城市从不下雪记忆却堆满冷的感觉思念的旺季霓虹扫过喧哗的街把快乐赶得好远落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞他陪我过夜","text":"我住的城市从不下雪记忆却堆满冷的感觉思念的旺季霓虹扫过喧哗的街把快乐赶得好远落单的恋人最怕过节只能独自庆祝尽量喝醉我爱过的人没有一个留在身边寂寞他陪我过夜 这是开心的一天 吃啥在南锣鼓巷 - 风铃酒馆 - 铃木食堂 - 秋刀鱼之味 玩啊在后海 - 北锣鼓巷 拍照哦三井胡同 - 豆瓣胡同 - 雨儿胡同 123那一家春饼店的草已经种下了旁边那家咖啡店很是不错","categories":[{"name":"生活","slug":"生活","permalink":"http://leeeing.com/categories/生活/"}],"tags":[{"name":"young","slug":"young","permalink":"http://leeeing.com/tags/young/"}]},{"title":"Hello World","slug":"important","date":"2017-12-27T11:38:35.000Z","updated":"2018-07-16T08:30:47.451Z","comments":true,"path":"2017/12/27/important/","link":"","permalink":"http://leeeing.com/2017/12/27/important/","excerpt":"路本来是平的走的人多了慢慢的坑，也被踩出来了","text":"路本来是平的走的人多了慢慢的坑，也被踩出来了 “What I cannot create, I do not understand.”– – Richard Feynman Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post123$ hexo new \"My New Post\"andhexo new page \"your new page name. eg: About\" More info: Writing Run server 预览 &amp; 在线调试 123$ hexo serverorhexo s More info: Server Generate static files 上传 &amp; 发布 123$ hexo generateorhexo g More info: Generating Deploy to remote sites这里有坑啊 踩了一天的坑1$ hexo deploy 这个方法我第一次使用的时候死没有错的，可是等我第二次部署的时候就出问题了原因在，我文件的 next 主题配置的 deploy 是有问题的（可能是我看某个教程里面键名是这样书写的 | 老版？）虽然，hexo d -g 之后也提示 INFO Deploy done: git但是，github上面却一直没有给我更新，一直提交，一直刷新，始终提示： there is nothing changes郁闷了一天之后，好好反思，发现，人家还是有提示的： 123456789101112You have to configure the deployment settings in _config.yml first!Example: deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] extend_dirs: [extend directory]For more help, you can check the docs: http://hexo.io/docs/deployment.html js1code snippet 然后更改键名设置 1234567891011deploy: type: git respository: git@github.com:leeexing/leeexing.github.io branch: master`修改之后`deploy: type: git repo: git@github.com:leeexing/leeexing.github.io branch: master hexo d -g 失败12345678Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Host key verification failed.fatal: Could not read from remote repository. 【解决方案】 1、使用https2、要不不要在 CMD里面使用 git 提交首先检测 本地电脑的密钥和github上面的密钥是否相同不同就设置git config –global user.name “”git config –global user.email “”在 git bash 里面提交。可能会让确认是否执行相应的操作 Bingo所以，还是自己没有切实理解人家给出的提示，并做出快速准确的修改这个锅，得自己背 More info: Deployment 如何管理如何第一次部署以及如何平时使用 选项卡 1选项卡 2选项卡 3选项卡 4选项卡 5第一步：建仓1、在本地建立一个仓库，链接远程仓库 XXX.github.io2、本地仓库建立一个分支，例如：hexo。但是主分支还是 master 第二步 建分支1、将HEAD指针指到 hexo。全部的编辑都在这个各分支里面。记住是全部2、第一次 git push origin hexo. 就是在远程仓库建立一个和本地仓库同样的分支hexo，并能建立其联系 第三步 部署1、安装 hexo-deployer-git2、一键部署。hexo clean – hexo d -g. 记住这时根据上面的配置，会将hexo g 生产的 public 文件夹里面的文件提交到远程仓库的 master 分支 第四步 之后1、以后，每次更改了 next 主题设置或者新增了一些文章，第一步，先提交到 远程的hexo分支上面2、然后，部署到对应的 git 远程仓库。实现：1、hexo 可以clone的文件；2、master 里面就是博客展现的内容 第四步 提醒1、有关主题的配置文件，最好在hexo路径下的source里面建立一个 _data 文件夹2、将next 的 config.yml 文件放入其中3、将主题有些模板的文件改动之类的备注好。例如 layout.swig、post.swigand4、在 source 文件夹下面增加一个 CNAME 文件。同时 hexo 里面配置 skip_render: CNAME 有待解决1、next 主题中的代码高亮似乎不能实现，都是同一个样式，网上查了资料，没有一个完美的解决方案。留着 感谢感谢这些前辈给的优秀建议 正确使用hexo的姿势","categories":[],"tags":[]}]}